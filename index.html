<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Typing Master</title>
  <link rel="icon" href="icon.png" type="image/png" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    /* --- Global Styles --- */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
      color: #d4d4d4;
      padding: 20px;
    }

    /* --- Container --- */
    .container {
      background: rgba(40, 40, 40, 0.8);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      padding: 30px;
      width: 100%;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      position: relative;
      overflow: hidden;
    }

    h1 {
      text-align: center;
      font-size: 2.2rem;
      font-weight: 600;
      background: linear-gradient(90deg, #88c0d0, #81a1c1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .welcome-banner {
      background: rgba(136, 192, 208, 0.1);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.95rem;
      text-align: center;
      color: #88c0d0;
      animation: fadeIn 0.8s ease forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #textDisplay {
      background: rgba(33, 33, 33, 0.7);
      padding: 18px;
      border-radius: 10px;
      min-height: 150px;
      font-family: "Roboto Mono", monospace;
      line-height: 1.7;
      font-size: 1.1rem;
      overflow: hidden;
    }
    #textDisplay span { transition: all 0.1s ease; }
    .correct { color: #a3be8c; }
    .incorrect { color: #bf616a; background-color: rgba(191, 97, 106, 0.15); }
    .current-char { background-color: #ebcb8b; color: #212121; padding: 0 2px; border-radius: 3px; }

    #userInput {
      width: 100%;
      height: 120px;
      font-size: 1rem;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      background: rgba(33, 33, 33, 0.8);
      color: #fff;
      outline: none;
      resize: none;
      font-family: "Roboto Mono", monospace;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    #userInput:focus {
      border-color: #88c0d0;
      box-shadow: 0 0 0 3px rgba(136, 192, 208, 0.2);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: space-between;
      align-items: flex-end;
    }
    .metrics {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.95rem;
    }
    .metrics div {
      background: rgba(255, 255, 255, 0.05);
      padding: 6px 10px;
      border-radius: 6px;
    }
    button {
      background: linear-gradient(90deg, #5e81ac, #81a1c1);
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      font-weight: 500;
      transition: transform 0.1s ease, opacity 0.2s ease;
    }
    button:hover { transform: translateY(-2px); opacity: 0.9; }
    button:disabled { background: #444; cursor: not-allowed; opacity: 0.6; }

    .time-period-selector {
      display: flex;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.85rem;
    }
    .time-period-selector label {
      flex: 1;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.05);
      transition: background 0.2s ease;
    }
    .time-period-selector input[type="radio"] { display: none; }
    .time-period-selector input:checked + label {
      background: #5e81ac;
      font-weight: bold;
    }
    .time-period-selector label:hover { background: rgba(136, 192, 208, 0.15); }

    .custom-text-option {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
    }
    .custom-text-area-wrapper {
      display: none;
      animation: fadeIn 0.4s ease;
    }
    .custom-text-area-wrapper.active { display: block; }
    #customParagraphInput {
      width: 100%;
      min-height: 80px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      background: rgba(33, 33, 33, 0.8);
      color: #fff;
      font-family: "Roboto Mono", monospace;
      padding: 10px;
    }

    .fancy-name {
      font-size: 10px;
      color: #88c0d0;
      text-align: center;
      margin-top: 15px;
      opacity: 0.8;
    }

    @media (max-width: 600px) {
      .controls { flex-direction: column; align-items: stretch; }
      button { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Typing Master</h1>
    <div class="welcome-banner">ðŸ’¡ Use default or custom text. Press "Start Test" to begin!</div>
    <div id="textDisplay"></div>
    <textarea id="userInput" placeholder="Start typing here..." disabled></textarea>

    <div class="controls">
      <div class="metrics">
        <div id="timer">Time: 00:00</div>
        <div id="accuracy">Accuracy: 100.00%</div>
        <div id="wpm">WPM: 0</div>
      </div>
      <div style="display: flex; gap: 10px;">
        <button id="startButton">Start Test</button>
        <button id="resetButton" style="display: none;">Reset Test</button>
      </div>
    </div>

    <div class="time-period-selector" id="timePeriodSelector"></div>
    <div class="custom-text-option">
      <input type="checkbox" id="useCustomTextCheckbox" />
      <label for="useCustomTextCheckbox">Use Custom Text</label>
    </div>
    <div class="custom-text-area-wrapper" id="customTextAreaWrapper">
      <textarea id="customParagraphInput" placeholder="Type or paste your custom paragraph here."></textarea>
    </div>

    <div class="fancy-name">Made by Aditya</div>
  </div>

  <script>
    /* Merged & Optimized JS */
    const textDisplay = document.getElementById('textDisplay');
    const userInput = document.getElementById('userInput');
    const timerElement = document.getElementById('timer');
    const accuracyElement = document.getElementById('accuracy');
    const wpmElement = document.getElementById('wpm');
    const startButton = document.getElementById('startButton');
    const resetButton = document.getElementById('resetButton');
    const timePeriodSelector = document.getElementById('timePeriodSelector');
    const useCustomTextCheckbox = document.getElementById('useCustomTextCheckbox');
    const customTextAreaWrapper = document.getElementById('customTextAreaWrapper');
    const customParagraphInput = document.getElementById('customParagraphInput');

    const defaultParagraph =
      "life is a journey filled with ups and downs and every person walks a path that is unique to them sometimes the road is smooth and easy and everything feels like it is going your way but other times challenges appear and you have to gather your strength to keep moving forward even when you feel tired or uncertain...";

    const timePeriods = [
      { value: 120, label: "2 Min" },
      { value: 300, label: "5 Min" },
      { value: 600, label: "10 Min" },
      { value: 0, label: "Free Mode" }
    ];

    let activeParagraph = defaultParagraph;
    let paragraphLines = [];
    let currentLineIndex = 0;
    const linesToShow = 3;
    let currentParagraphText = '';
    let startTime, timerInterval, running = false;
    let totalErrors = 0, totalTypedCharacters = 0, totalCorrectCharacters = 0, maxTime = 0;

    const formatTime = sec => `${String(Math.floor(sec / 60)).padStart(2,'0')}:${String(sec % 60).padStart(2,'0')}`;

    const splitParagraphIntoLines = (text, charsPerLine = 70) => {
      if (!text.trim()) return ["Start typing in the custom text area to begin practice!"];
      const words = text.split(' ');
      let lines = [], line = '';
      words.forEach(word => {
        if ((line + word).length + 1 > charsPerLine) {
          lines.push(line.trim());
          line = word + ' ';
        } else line += word + ' ';
      });
      if (line) lines.push(line.trim());
      return lines;
    };

    const formatTextSegmentForDisplay = text => text.split('').map(c => `<span>${c}</span>`).join('');

    const updateDisplayLines = () => {
      currentParagraphText = paragraphLines.slice(currentLineIndex, currentLineIndex + linesToShow).join(' ');
      textDisplay.innerHTML = formatTextSegmentForDisplay(currentParagraphText);
      applyTypingFeedback(userInput.value);
    };

    const calculateFeedback = (typed, target) => {
      let correct = 0, incorrect = 0;
      for (let i = 0; i < Math.min(typed.length, target.length); i++) {
        if (typed[i] === target[i]) correct++;
        else incorrect++;
      }
      if (typed.length > target.length) incorrect += typed.length - target.length;
      return { correct, incorrect, typed: typed.length };
    };

    const updateMetrics = (elapsed, input) => {
      const f = calculateFeedback(input, currentParagraphText);
      const liveCorrect = totalCorrectCharacters + f.correct;
      const liveTyped = totalTypedCharacters + f.typed;
      const acc = liveTyped ? (liveCorrect / liveTyped) * 100 : 100;
      accuracyElement.textContent = `Accuracy: ${acc.toFixed(2)}%`;
      const wpm = elapsed ? Math.round((liveCorrect / 5) / (elapsed / 60)) : 0;
      wpmElement.textContent = `WPM: ${wpm}`;
    };

    const applyTypingFeedback = input => {
      const spans = textDisplay.querySelectorAll('span');
      spans.forEach((span, i) => {
        span.classList.remove('correct','incorrect','current-char');
        if (i < input.length) span.classList.add(input[i] === currentParagraphText[i] ? 'correct' : 'incorrect');
        else if (i === input.length) span.classList.add('current-char');
      });
    };

    const startTimer = () => {
      if (running) return;
      running = true;
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        timerElement.textContent = `Time: ${formatTime(elapsed)}`;
        updateMetrics(elapsed, userInput.value);
        if (maxTime > 0 && elapsed >= maxTime) finishTest();
      }, 1000);
    };

    const stopTimer = () => { clearInterval(timerInterval); running = false; };

    const checkLineCompletion = () => {
      if (userInput.value.trim() === currentParagraphText) {
        const f = calculateFeedback(userInput.value, currentParagraphText);
        totalCorrectCharacters += f.correct;
        totalErrors += f.incorrect;
        totalTypedCharacters += f.typed;
        currentLineIndex += linesToShow;
        userInput.value = '';
        currentLineIndex < paragraphLines.length ? updateDisplayLines() : finishTest();
      }
    };

    const finishTest = () => {
      stopTimer();
      userInput.disabled = true;
      startButton.style.display = 'none';
      resetButton.style.display = 'inline-block';
      const finalTime = Math.floor((Date.now() - startTime) / 1000);
      updateMetrics(finalTime, userInput.value);
      textDisplay.innerHTML = `<p style="text-align:center;font-size:1.5em;color:#a3be8c;">Test Completed!</p>`;
    };

    const resetTest = () => {
      stopTimer();
      Object.assign(userInput, { value: '', disabled: true });
      timerElement.textContent = "Time: 00:00";
      accuracyElement.textContent = "Accuracy: 100.00%";
      wpmElement.textContent = "WPM: 0";
      totalErrors = totalTypedCharacters = totalCorrectCharacters = 0;
      currentLineIndex = 0;
      startButton.style.display = 'inline-block';
      resetButton.style.display = 'none';
      activeParagraph = useCustomTextCheckbox.checked ? customParagraphInput.value : defaultParagraph;
      paragraphLines = splitParagraphIntoLines(activeParagraph);
      updateDisplayLines();
    };

    const generateTimePeriodOptions = () => {
      timePeriodSelector.innerHTML = '';
      timePeriods.forEach(period => {
        const input = Object.assign(document.createElement('input'), {
          type: 'radio', id: `time-${period.value}`, name: 'timePeriod', value: period.value
        });
        const label = Object.assign(document.createElement('label'), { htmlFor: input.id, textContent: period.label });
        if (period.value === maxTime) input.checked = true;
        input.addEventListener('change', () => { if (input.checked) maxTime = parseInt(input.value); });
        timePeriodSelector.append(input, label);
      });
    };

    /* Event Listeners */
    useCustomTextCheckbox.addEventListener('change', () => {
      customTextAreaWrapper.classList.toggle('active', useCustomTextCheckbox.checked);
      activeParagraph = useCustomTextCheckbox.checked ? customParagraphInput.value : defaultParagraph;
      paragraphLines = splitParagraphIntoLines(activeParagraph);
      updateDisplayLines();
    });
    customParagraphInput.addEventListener('input', () => {
      if (useCustomTextCheckbox.checked) {
        activeParagraph = customParagraphInput.value;
        paragraphLines = splitParagraphIntoLines(activeParagraph);
        updateDisplayLines();
      }
    });
    startButton.addEventListener('click', () => {
      activeParagraph = useCustomTextCheckbox.checked ? customParagraphInput.value : defaultParagraph;
      if (useCustomTextCheckbox.checked && !activeParagraph.trim()) {
        alert("Please enter custom text or uncheck the option.");
        return;
      }
      userInput.disabled = false;
      userInput.focus();
      startButton.style.display = 'none';
      resetButton.style.display = 'inline-block';
      paragraphLines = splitParagraphIntoLines(activeParagraph);
      updateDisplayLines();
      startTimer();
    });
    resetButton.addEventListener('click', resetTest);
    userInput.addEventListener('input', e => {
      if (!running && e.target.value.length > 0) startTimer();
      updateMetrics(Math.floor((Date.now() - startTime) / 1000), e.target.value);
      applyTypingFeedback(e.target.value);
      checkLineCompletion();
    });

    /* Init */
    window.onload = () => {
      maxTime = 0;
      generateTimePeriodOptions();
      paragraphLines = splitParagraphIntoLines(defaultParagraph);
      updateDisplayLines();
    };
  </script>
</body>
</html>
